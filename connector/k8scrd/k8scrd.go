// Package ldap implements strategies for authenticating using the protocol.
package k8scrd

import (
	"bytes"
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"

	"github.com/dexidp/dex/connector"
	"github.com/dexidp/dex/pkg/log"
)

// Config holds configuration options for auth server
type Config struct {
	// The host and optional port of the LDAP server. If port isn't supplied, it will be
	// guessed based on the TLS configuration. 389 or 636.
	Host string `json:"host"`

	// Required if LDAP host does not use TLS.
	InsecureNoSSL bool `json:"insecureNoSSL"`

	// Don't verify the CA.
	InsecureSkipVerify bool `json:"insecureSkipVerify"`
	// Connect to the insecure port then issue a StartTLS command to negotiate a
	// secure connection. If unsupplied secure connections will use the LDAPS
	// protocol.
	StartTLS bool `json:"startTLS"`

	// Path to a trusted root certificate file.
	RootCA string `json:"rootCA"`
	// Path to a client cert file generated by rootCA.
	ClientCert string `json:"clientCert"`
	// Path to a client private key file generated by rootCA.
	ClientKey string `json:"clientKey"`
	// Base64 encoded PEM data containing root CAs.
	RootCAData []byte `json:"rootCAData"`
}

type k8scrdConnector struct {
	Config
	logger log.Logger
}

type User struct {
	Name     string `json:"name"`
	Password string `json:"password"`
}

type UserResponse struct {
	UserID string `json:"userID"`
	Name   string `json:"name"`
	// Unique email address(https://www.ietf.org/rfc/rfc5322.txt).
	Email string `json:"email"`
	// phone number of user
	Phone string `json:"phone,omitempty"`
	// The preferred written or spoken language for the user.
	// +optional
	Lang string `json:"lang,omitempty"`
	// Description of the user.
	// +optional
	Description string `json:"description,omitempty"`
	// +optional
	DisplayName string `json:"displayName,omitempty"`

	// +optional
	Groups []string `json:"groups,omitempty"`

	// user role, on of admin,platform,infrastruce, empty is common user
	Role string `json:"role"`
}

var (
	_ connector.PasswordConnector = (*k8scrdConnector)(nil)
	_ connector.RefreshConnector  = (*k8scrdConnector)(nil)
)

func (c *Config) Open(id string, logger log.Logger) (connector.Connector, error) {
	return &k8scrdConnector{
		Config: *c,
		logger: logger,
	}, nil
}

func (c *k8scrdConnector) Login(ctx context.Context, s connector.Scopes, username, passowrd string) (identity connector.Identity, validPass bool, err error) {
	c.logger.Debugf("userName: %s, password: %s", username, passowrd)
	resp, err := c.getRespose(ctx, username, passowrd)
	if err != nil {
		return identity, false, fmt.Errorf("auth failed: ", err)
	}
	// if statusCode == http.StatusMovedPermanently,  oidc-server will redirect to the location adress.
	if resp.StatusCode == http.StatusMovedPermanently {
		identity.ConnectorData = []byte(resp.Header.Get("Location"))
		return identity, false, nil
	}

	if resp.StatusCode != http.StatusOK {
		return identity, false, fmt.Errorf("response status code: %d, error message: ", resp.StatusCode)
	}
	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return identity, false, err
	}
	defer resp.Body.Close()
	//TODO check resp.StatusCode
	userResp := new(UserResponse)
	err = json.Unmarshal(data, &userResp)
	if err != nil {
		return identity, false, fmt.Errorf("k8scrd: invalid response: %v", err)
	}

	identity.Username = userResp.Name
	identity.UserID = userResp.UserID
	if userResp.UserID == "" {
		identity.UserID = userResp.Name
	}
	identity.PreferredUsername = userResp.Name
	identity.Email = userResp.Email
	//TODO verfiy Email
	identity.EmailVerified = true
	identity.Groups = userResp.Groups
	return identity, true, nil
}
func (c *k8scrdConnector) Prompt() string {
	return "k8scrd"
}

func (c *k8scrdConnector) Refresh(ctx context.Context, s connector.Scopes, identity connector.Identity) (connector.Identity, error) {
	return identity, nil
}

func (c *k8scrdConnector) getRespose(ctx context.Context, username, pass string) (response *http.Response, err error) {
	tlsConfig := &tls.Config{
		InsecureSkipVerify: c.InsecureSkipVerify}
	if c.RootCA != "" || len(c.RootCAData) != 0 {
		data := c.RootCAData
		if len(data) == 0 {
			if data, err = os.ReadFile(c.RootCA); err != nil {
				return nil, fmt.Errorf("k8scrd: read ca file: %v", err)
			}
		}
		rootCAs := x509.NewCertPool()
		if !rootCAs.AppendCertsFromPEM(data) {
			return nil, fmt.Errorf("k8scrd: no certs found in ca file")
		}
	}
	if c.ClientKey != "" && c.ClientCert != "" {
		cert, err := tls.LoadX509KeyPair(c.ClientCert, c.ClientKey)
		if err != nil {
			return nil, fmt.Errorf("k8scrd: load client cert failed: %v", err)
		}
		tlsConfig.Certificates = append(tlsConfig.Certificates, cert)
	}

	client := &http.Client{Transport: &http.Transport{
		TLSClientConfig: tlsConfig,
	},
		// disable net/http  auto redirect feature
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse

		}}

	jsonData := User{
		Name:     username,
		Password: pass,
	}
	jsonValue, err := json.Marshal(jsonData)
	if err != nil {
		return nil, err
	}
	cookieID := fmt.Sprintf("%v", ctx.Value("cookieid"))

	if username == "" && pass == "" && cookieID == "" {
		return nil, fmt.Errorf("username or password is nil or cookie is nil. username: %s, password: %s, cookieid: %s", username, pass, cookieID)
	}

	authURL := c.Host + "/login"
	if cookieID != "" {
		authURL = authURL + fmt.Sprintf("?cookieid=%s", url.QueryEscape(cookieID))
	}
	req, err := http.NewRequest("POST", authURL, bytes.NewBuffer(jsonValue))

	req.Header.Set("Content-Type", "application/json")
	req = req.WithContext(ctx)
	return client.Do(req)

}
